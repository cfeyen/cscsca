#![doc = include_str!("../README.md")]

use std::error::Error;

mod ir;
mod phones;
mod tokens;
mod rules;
mod applier;
mod matcher;
mod sub_string;
mod escaped_strings;
mod color;
mod executor;
mod keywords;
mod io_macros;

pub use crate::{
    executor::{
        LineByLineExecuter,
        appliable_rules::{
            build_rules,
            AppliableRules,
        },
        runtime::{
            Runtime,
            LineApplicationLimit,
            CliRuntime,
            LogRuntime,
            LogAndPrintRuntime,
        },
        getter::{
            IoGetter,
            CliGetter,
        },
    },
};

use io_macros::{
    await_io,
    io_fn,
};

#[cfg(test)]
mod tests;

/// Applies sca source code to an input string
/// 
/// Returns a string of either the final text or a formatted error
/// 
/// ## Note:
/// IO is done through the standard io
#[inline]
#[must_use]
#[io_fn]
pub fn apply(input: &str, rules: &str) -> String {
    await_io! {
        apply_fallible(input, rules)
    }.unwrap_or_else(|e| e.to_string())
}

/// Applies sca source code to an input string
/// 
/// ## Errors
/// Errors on invalid rules, application that takes too long, and failed io
/// 
/// ## Note:
/// IO is done through the standard io
#[inline]
#[io_fn]
pub fn apply_fallible(input: &str, rules: &str) -> Result<String, ScaError> {
    let getter = CliGetter::new();
    let runtime = CliRuntime::default();
    await_io! {
        LineByLineExecuter::new(runtime, getter).apply_fallible(input, rules)
    }
}

#[cfg(feature = "docs")]
/// Returns the content of the README markdown file pertaining to writing sound change rules
#[must_use]
pub const fn docs() -> &'static str {
    include_str!("../docs/writing_rules.md")
}

/// An error generated by the building or application of sound change rules
/// or IO fetched during either process
#[cfg_attr(test, derive(PartialEq))]
#[derive(Debug)]
pub struct ScaError {
    err: String,
    line: String,
    line_num: usize,
    from_io: bool, 
}

impl Error for ScaError {}

impl ScaError {
    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub fn error_message(&self) -> &str {
        &self.err
    }

    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub const fn line_number(&self) -> usize {
        self.line_num
    }

    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub fn line(&self) -> &str {
        &self.line
    }

    /// Returns `true` if the error was caused by getting or writing IO
    #[must_use]
    #[inline]
    pub fn is_io_error(&self) -> bool {
        self.from_io
    }

    /// Builds a new `ScaError` from any error,
    /// with the line and line number it occurred on
    fn from_error<E: Error + ?Sized>(e: &E, line: &str, line_num: usize) -> Self {
        Self {
            err: e.to_string(),
            line: line.to_string(),
            line_num,
            from_io: false,
        }
    }

    fn from_io_error<E: Error + ?Sized>(e: &E, line: &str, line_num: usize) -> Self {
        Self {
            err: e.to_string(),
            line: line.to_string(),
            line_num,
            from_io: true,
        }
    }
}

impl std::fmt::Display for ScaError {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.from_io {
            write!(f, "{}IO Error: {}", color::RED, color::RESET)?;
        } else {
            write!(f, "{}Error: {}", color::RED, color::RESET)?;
        }
        writeln!(f, "{}", self.err)?;
        write!(f, "Line {}: {}", self.line_num, self.line)
    }
}
#![doc = include_str!("../README.md")]

use std::{error::Error, num::NonZero};

mod ir;
mod phones;
mod tokens;
mod rules;
mod applier;
mod matcher;
mod sub_string;
mod escaped_strings;
mod executor;
mod keywords;
mod io_macros;

pub use crate::{
    executor::{
        LineByLineExecuter,
        appliable_rules::{
            build_rules,
            AppliableRules,
        },
        runtime::{
            Runtime,
            LineApplicationLimit,
            LogRuntime,
        },
        getter::IoGetter,
    },
};

use io_macros::{
    await_io,
    io_fn,
};

#[cfg(test)]
pub(crate) mod tests;

/// `NonZero` wrapped `1`
const ONE: NonZero<usize> = NonZero::new(1).expect("1 ought to be nonzero");

#[cfg(feature = "docs")]
/// Returns the content of the README markdown file pertaining to writing sound change rules
#[must_use]
pub const fn docs() -> &'static str {
    include_str!("../docs/writing_rules.md")
}

/// A type of error
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ScaErrorType {
    /// Error occurred when fetching input
    Input,
    /// Error occurred when logging output
    Output,
    /// Error occurred when parsing rules
    Parse,
    /// Error occurred when applying changes
    Application,
}

impl std::fmt::Display for ScaErrorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Input => write!(f, "Input"),
            Self::Output => write!(f, "Output"),
            Self::Parse => write!(f, "Syntax"),
            Self::Application => write!(f, "Application"),
        }
    }
}

/// An error generated by the building or application of sound change rules
/// or by IO fetched during either process
#[cfg_attr(test, derive(PartialEq))]
#[derive(Debug)]
pub struct ScaError {
    err: String,
    rule: String,
    line_num: NonZero<usize>,
    line_count: NonZero<usize>,
    error_type: ScaErrorType, 
}

impl Error for ScaError {}

impl ScaError {
    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub fn error_message(&self) -> &str {
        &self.err
    }

    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub const fn line_number(&self) -> NonZero<usize> {
        self.line_num
    }

    /// Returns the number of lines on which the error occured
    #[must_use]
    #[inline]
    pub const fn line_count(&self) -> NonZero<usize> {
        self.line_count
    }

    /// Returns the number of the line on which the error occured
    #[must_use]
    #[inline]
    pub fn rule(&self) -> &str {
        &self.rule
    }

    /// Returns the type of error
    #[must_use]
    #[inline]
    pub const fn error_type(&self) -> ScaErrorType {
        self.error_type
    }
}

impl std::fmt::Display for ScaError {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{} Error: {}", self.error_type, self.err)?;
        
        if self.line_count == ONE {
            write!(f, "Line {}", self.line_num)?;
        } else {
            write!(f, "Lines {}-{}", self.line_num, self.line_num.get() + self.line_count.get() - 1)?;
        }

        write!(f, ": {}", self.rule)
    }
}

/// An error generated by the building or application of sound change rules
/// or by IO fetched during either process
/// 
/// Converted into an ScaError before being displayed
#[derive(Debug)]
struct RulelessScaError {
    err: String,
    line_num: NonZero<usize>,
    line_count: NonZero<usize>,
    error_type: ScaErrorType, 
}

impl Error for RulelessScaError {}

impl RulelessScaError {
    /// Converts into an `ScaError`, getting the rule from an iterator over the lines of the origional rule input
    fn into_sca_error<'a>(self, lines: impl Iterator<Item = &'a str>) -> ScaError {
        let rule = lines
            .skip(self.line_num.get() - 1)
            .take(self.line_count.get())
            .collect::<Vec<_>>()
            .join("\n");

        ScaError {
            err: self.err,
            rule,
            line_num: self.line_num,
            line_count: self.line_count,
            error_type: self.error_type,
        }
    }

    /// Builds a new `ScaError` from any error,
    /// with the line and line number it occurred on
    fn from_error<E: Error + ?Sized>(e: &E, error_type: ScaErrorType, line_num: NonZero<usize>, line_count: NonZero<usize>) -> Self {
        Self {
            err: e.to_string(),
            line_num,
            line_count,
            error_type,
        }
    }
}

impl std::fmt::Display for RulelessScaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{} Error: {}", self.error_type, self.err)?;
        
        if self.line_count == ONE {
            write!(f, "Line {}", self.line_num)
        } else {
            write!(f, "Lines {}-{}", self.line_num, self.line_num.get() + self.line_count.get() - 1)
        }
    }
}
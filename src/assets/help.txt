[m]+------+  +-----+  +------+  +-----+  +------+  +-------+[-]
[m]|         |Super   |         |Sound   |         |Applier|[-]
[m]|         +-----+  |         +-----+  |         +-------+[-]    
[m]|Charles'       |  |Cool           |  |Change   |       |[-]
[m]+------+  +-----+  +------+  +-----+  +------+  +       +[-]

[m]Charles' Super Cool Sound Change Applier[-]

[m]Command Arguments[-]:
[m]cscsca[-] [g][!]sca[-] [b]path[-] [b]text[-]
- Applies the changes specified in the file at [b]path[-] to [b]text[-]

    [m]Phones[-]: phones are any group of non-special characters that are not seperated by whitespace
        Examples: p, t, a, ts, lh, á
        Note: in an input adjacent characters such as '[y]ts[-]' or '[y]á[-]' ('[y]a[-]' + '[y]\u{301}[-]')
            are read as pairs of phones, these can be merged into single phones
            at the start of the program using rules like '[g]t s >> ts[-]' and '[g]a ́ >> á[-]'

    [m]Rules[-]: a rule is a sound change that the SCA applies to [b]text[-]
        A simple rule is structured like: input [b]shift type[-] output
        After the output any number of coniditons may be added as: [g]/[-] [b]condition[-]
        After the conditions any number of anti-conditions may added as: [g]//[-] [b]anti-condition[-]

        [m]Shift Types[-]
            [m]LTR vs RTL[-]
                [m]LTR[-]: '[g]>[-]' or '[g]>>[-]': applies a change from left to right

                [m]RTL[-]: '[g]<[-]' or '[g]<<[-]': applies a change from right to left

            [m]Move vs Stay[-]
                [m]Move[-]: a move shift, '[g]>>[-]' or '[g]<<[-]', attempts the sound change again
                at the next phone [!]after[-] the output of a successful change

                [m]Stay[-] a stay shift, '[g]>[-]' or '[g]<[-]', attempts the sound change again
                [!]at[-] the output of a successful change
                    [r]WARNING[-]: using a stay shift may result in an infinite loop
                        (if this happens use [!]Ctrl+C[-] to stop the program)

                If the last change was not successful,
                both types move one phone in the specified direction

        [m]Conditions[-]
            Evey condition or anti-condition must contain exactally one input pattern: '[g]_[-]'
            The input pattern represents the input of the rule, the phones around the pattern
            represent the enviroment in which the input should become the output
            Example: [g]t >> tʃ / _ i[-]
                '[y]t[-]' becomes '[y]tʃ[-]' [!]when[-] before '[y]i[-]' 
            
            [m]Condition Specific Tokens[-]:
            (tokens that may only be used in conditions)
                [m]And[-]: '[g]&[-]'
                    Acts as a seperator between two conditions that must both succeed
                    Example: [g]h >> / {#, l, r} _ & {#, m, n} _[-]
                        '[y]h[-]' is droped when following '[y]#[-]' as '[y]#[-]' is in both [g]{#, l, r}[-] and [g]{#, m, n}[-]
                        Note: this is the same as [g]h >> / # _[-]

                [m]Gap[-]: '[g]..[-]' a gap of 0 or more phones
                    (must have a space on both sides)
                    Gaps may be labeled to agree (see '[m]Labels[-]'), however, as they only
                    exist in conditions, they do not have any default agreement

    [m]Scopes[-]:
        [m]Selection[-]:
            A list lists of phones or other tokens, one of which will be inserted into the
            [b]input[-]/[b]output[-]/[b]condition[-]/[b]anti-condition[-] if it fits in the context of [b]text[-]
            (each list is seperated by a '[g],[-]')

        [m]Optional[-]:
            A list of phones or other tokens that will be inserted into the
            [b]input[-]/[b]output[-]/[b]condition[-]/[b]anti-condition[-] if it fits in the context of [b]text[-],
            otherwise it will be ommited

        [m]Any[-]:
            A '[g]*[-]' acts as any phone that is not a word boundary.
            Anys may be selected to agree in what phone they represent

    [m]Labels[-]:
        A label '[g]$[-][b]name[-]' may be used to force agreement between scopes and gaps
        While corresponding scopes on opposite sides of the [b]shift type[-] have
        some automatic agreement, labels can create more complex agreement.
        Example: [g]$place{ m, n, ng } $place{ p, t, k } >> $place{ b, d, ng }[-]
            (all selections will pick corresponding phones)
        Notes:
            Gaps that agree are less than or equal in length to the defining gap, not only equal
            In [b]conditions[-], phones are analyzed from the [b]input[-] left, then from the [b]input[-] right
        

    [m]Comments[-]: Comments are lines that start with '[g]##[-]'. They are ignored by the SCA.

    [m]Statements[-]:
        Written: [m]CMD[-] args
        Non-rule commands 

        [g]DEFINE[-] [b]name[-] [b]contents[-]
            To insert the [b]contents[-] into a rule later, use '[g]@[-][b]name[-]'

        [g]PRINT[-] [b]label[-]:
            Prints the phones at that point in the sound change process
            with the proceeded by the [b]label[-]

        [g]GET[-] [b]name[-] [b]message[-]:
            Prints the [b]message[-] then waits for the user to input a response,
            To insert the respone into a rule later, use '[g]%[-][b]name[-]'
            [r]IMPORTANT[-]: the response is treated as a single phone

        [g]GET_AS_CODE[-] [b]name[-] [b]message[-]:
            Prints the [b]message[-] then waits for the user to input a response,
            To insert the respone into a rule later, use '[g]%[-][b]name[-]'
            [r]IMPORTANT [-]: the response is treated the same as code which could result in
            unexpected errors depending on the input

    [m]Other[-]:
        A '[y]#[-]' phone acts as a word boundary
        A '[y]\[-]' can escape the special effects of the following character or whitespace

[m]cscsca[-] [g][!]apply[-] [b]code_file[-] [b]text_file[-]
    Prints the result of appling the code in [b]code_file[-] to [b]text_file[-]

[m]cscsca[-] [g][!]apply[-] [b]code_file[-] [b]text_file[-] [b]target_file[-]
    Prints the result of appling the code in [b]code_file[-] to [b]text_file[-] in [b]target_file[-]

[m]cscsca[-] [g][!]chars[-] [b]text[-]
- Prints every character in [b]text[-] on a new line.

    Certain characters like '[y]á[-]' are actually multiple characters ('[y]a[-]' + '[y]\u{301}[-]')
    (notes:
        there is an identical varient '[y]á[-]' that is actually one character,
        the combining character '[y] ́[-]' cannot be represented as '[y]\u{301}[-]' it must be '[y] ́[-]'
    )
    This tool helps determine which special characters are actually multiple
        - These seperate characters can be merged into one phone '[y]á[-]' using '[g]a ́ >> á[-]'
        (note the final '[y]á[-]' is still two characters new but represent one phone like how
        '[g]t s >> ts[-]' ends in '[y]ts[-]' as one phone represented by two characters)

[m]cscsca[-] [g][!]demo[-]
    Prints the demo file

[m]cscsca[-] [g][!]new[-] [b]name[-]
    Creates a new template file with the name [b]name[-]

[m]cscsca[-] [g][!]help[-]
    Prints this file